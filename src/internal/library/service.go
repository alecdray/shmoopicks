package library

import (
	"context"
	"fmt"
	"shmoopicks/src/internal/core/db"
	"shmoopicks/src/internal/core/db/models"
	"shmoopicks/src/internal/core/db/sqlc"
	"sort"
	"time"

	"github.com/google/uuid"
)

type ReleaseDTO struct {
	ID      string
	AlbumID string
	Format  models.ReleaseFormat
	AddedAt *time.Time
}

func NewReleaseDTOFromModel(model sqlc.Release, userRelease *sqlc.UserRelease) ReleaseDTO {
	dto := ReleaseDTO{
		ID:      model.ID,
		AlbumID: model.AlbumID,
		Format:  model.Format,
	}

	if userRelease != nil {
		dto.AddedAt = &userRelease.AddedAt
	}

	return dto
}

type ReleaseDTOs []ReleaseDTO

func (releases ReleaseDTOs) OldestAddedAtDate() *time.Time {
	var oldest *time.Time
	for _, r := range releases {
		if r.AddedAt != nil {
			if oldest == nil || r.AddedAt.Before(*oldest) {
				oldest = r.AddedAt
			}
		}
	}
	return oldest
}

func (releases ReleaseDTOs) FindFormat(format models.ReleaseFormat) *ReleaseDTO {
	for _, r := range releases {
		if r.Format == format {
			return &r
		}
	}
	return nil
}

type TrackDTO struct {
	ID        string
	SpotifyID string
	Title     string
}

func NewTrackDTOFromModel(model sqlc.Track) TrackDTO {
	dto := TrackDTO{
		ID:        model.ID,
		SpotifyID: model.SpotifyID,
		Title:     model.Title,
	}

	return dto
}

type ArtistDTO struct {
	ID        string
	SpotifyID string
	Name      string
}

func NewArtistDTOFromModel(model sqlc.Artist) ArtistDTO {
	dto := ArtistDTO{
		ID:        model.ID,
		SpotifyID: model.SpotifyID,
		Name:      model.Name,
	}

	return dto
}

type AlbumDTO struct {
	ID        string
	SpotifyID string
	Title     string
	Artists   []ArtistDTO
	Tracks    []TrackDTO
	Releases  ReleaseDTOs
}

func NewAlbumDTOFromModel(model sqlc.Album, artists []ArtistDTO, tracks []TrackDTO, releases []ReleaseDTO) AlbumDTO {
	return AlbumDTO{
		ID:        model.ID,
		SpotifyID: model.SpotifyID,
		Title:     model.Title,
		Artists:   artists,
		Tracks:    tracks,
		Releases:  releases,
	}
}

type AlbumDTOs []AlbumDTO

func (albums AlbumDTOs) SortByTitle(ascending bool) {
	sort.Slice(albums, func(i, j int) bool {
		if ascending {
			return albums[i].Title < albums[j].Title
		}
		return albums[i].Title > albums[j].Title
	})
}

func (albums AlbumDTOs) SortByArtist(ascending bool) {
	sort.Slice(albums, func(i, j int) bool {
		if len(albums[i].Artists) == 0 && len(albums[j].Artists) == 0 {
			return false
		}
		if len(albums[i].Artists) == 0 {
			return ascending
		}
		if len(albums[j].Artists) == 0 {
			return !ascending
		}
		if ascending {
			return albums[i].Artists[0].Name < albums[j].Artists[0].Name
		}
		return albums[i].Artists[0].Name > albums[j].Artists[0].Name
	})
}

func (albums AlbumDTOs) SortByDate(ascending bool) {
	sort.Slice(albums, func(i, j int) bool {
		dateI := albums[i].Releases.OldestAddedAtDate()
		dateJ := albums[j].Releases.OldestAddedAtDate()
		if dateI == nil && dateJ == nil {
			return false
		}
		if dateI == nil {
			return ascending
		}
		if dateJ == nil {
			return !ascending
		}
		if ascending {
			return dateI.Before(*dateJ)
		}
		return dateI.After(*dateJ)
	})
}

type Library struct {
	OwnerUserID string
	Albums      AlbumDTOs
	Artists     []ArtistDTO
	Tracks      []TrackDTO
}

func NewLibrary(ownerUserID string, albums []AlbumDTO) *Library {
	lib := &Library{
		OwnerUserID: ownerUserID,
		Albums:      albums,
	}

	lib.Artists = lib.artists()
	lib.Tracks = lib.tracks()

	return lib
}

func (l *Library) artists() []ArtistDTO {
	artistsSet := make(map[string]ArtistDTO)
	for _, album := range l.Albums {
		for _, artist := range album.Artists {
			artistsSet[artist.ID] = artist
		}
	}

	artists := make([]ArtistDTO, 0, len(artistsSet))
	for _, artist := range artistsSet {
		artists = append(artists, artist)
	}

	return artists
}

func (l *Library) tracks() []TrackDTO {
	tracksSet := make(map[string]TrackDTO)
	for _, album := range l.Albums {
		for _, track := range album.Tracks {
			tracksSet[track.ID] = track
		}
	}

	tracks := make([]TrackDTO, 0, len(tracksSet))
	for _, track := range tracksSet {
		tracks = append(tracks, track)
	}

	return tracks
}

type Service struct {
	db *db.DB
}

func NewService(db *db.DB) *Service {
	return &Service{
		db: db,
	}
}

func (s *Service) GetReleasesInLibrary(ctx context.Context, userId string) ([]ReleaseDTO, error) {
	releases, err := s.db.Queries().GetUserReleases(ctx, userId)
	if err != nil {
		err = fmt.Errorf("failed to get user releases: %w", err)
		return nil, err
	}

	var releaseDTOs []ReleaseDTO
	for _, release := range releases {
		releaseDTOs = append(releaseDTOs, NewReleaseDTOFromModel(release.Release, &release.UserRelease))
	}

	return releaseDTOs, nil
}

func (s *Service) GetAlbumsInLibrary(ctx context.Context, userId string) ([]AlbumDTO, error) {
	releases, err := s.GetReleasesInLibrary(ctx, userId)
	if err != nil {
		err = fmt.Errorf("failed to get releases: %w", err)
	}

	releasesByAlbumId := make(map[string][]ReleaseDTO, len(releases))
	albumIds := make([]string, 0, len(releases))
	for _, release := range releases {
		albumIds = append(albumIds, release.AlbumID)
		releasesByAlbumId[release.AlbumID] = append(releasesByAlbumId[release.AlbumID], release)

	}

	albums, err := s.db.Queries().GetAlbumsByIDs(ctx, albumIds)
	if err != nil {
		err = fmt.Errorf("failed to get albums: %w", err)
		return nil, err
	}

	artists, err := s.db.Queries().GetAlbumArtistsByAlbumIds(ctx, albumIds)
	if err != nil {
		err = fmt.Errorf("failed to get album artists: %w", err)
		return nil, err
	}

	artistsByAlbumId := make(map[string][]ArtistDTO, len(albumIds))
	for _, artist := range artists {
		artistsByAlbumId[artist.AlbumID] = append(artistsByAlbumId[artist.AlbumID], NewArtistDTOFromModel(artist.Artist))
	}

	tracks, err := s.db.Queries().GetAlbumTracksByAlbumIds(ctx, albumIds)
	if err != nil {
		err = fmt.Errorf("failed to get album tracks: %w", err)
		return nil, err
	}

	tracksByAlbumId := make(map[string][]TrackDTO, len(albumIds))
	for _, track := range tracks {
		tracksByAlbumId[track.AlbumID] = append(tracksByAlbumId[track.AlbumID], NewTrackDTOFromModel(track.Track))
	}

	var albumDTOs []AlbumDTO
	for _, album := range albums {
		dto := NewAlbumDTOFromModel(
			album,
			artistsByAlbumId[album.ID],
			tracksByAlbumId[album.ID],
			releasesByAlbumId[album.ID],
		)
		albumDTOs = append(albumDTOs, dto)
	}

	return albumDTOs, nil
}

func (s *Service) GetLibrary(ctx context.Context, userId string) (*Library, error) {
	albums, err := s.GetAlbumsInLibrary(ctx, userId)
	if err != nil {
		err = fmt.Errorf("failed to get user albums: %w", err)
		return nil, err
	}

	return NewLibrary(userId, albums), nil
}

func (s *Service) AddAlbumsToLibrary(ctx context.Context, userId string, albums []AlbumDTO) error {
	err := s.db.WithTx(func(tx *db.DB) error {
		for _, album := range albums {
			// insert album
			albumModel, err := tx.Queries().GetOrCreateAlbum(ctx, sqlc.GetOrCreateAlbumParams{
				ID:        album.ID,
				SpotifyID: album.SpotifyID,
				Title:     album.Title,
			})
			if err != nil {
				err = fmt.Errorf("failed to get/create album: %w", err)
				return err
			}
			album = NewAlbumDTOFromModel(albumModel, album.Artists, album.Tracks, album.Releases)

			for i, track := range album.Tracks {
				// insert tracks
				trackModel, err := tx.Queries().GetOrCreateTrack(ctx, sqlc.GetOrCreateTrackParams{
					ID:        track.ID,
					SpotifyID: track.SpotifyID,
					Title:     track.Title,
				})
				if err != nil {
					err = fmt.Errorf("failed to get/create track: %w", err)
					return err
				}

				// insert album_tracks
				_, err = tx.Queries().GetOrCreateAlbumTrack(ctx, sqlc.GetOrCreateAlbumTrackParams{
					AlbumID: albumModel.ID,
					TrackID: trackModel.ID,
				})
				if err != nil {
					err = fmt.Errorf("failed to get/create album track: %w", err)
					return err
				}

				album.Tracks[i] = NewTrackDTOFromModel(trackModel)
			}

			for i, artist := range album.Artists {
				// insert artsits
				artistModel, err := tx.Queries().GetOrCreateArtist(ctx, sqlc.GetOrCreateArtistParams{
					ID:        artist.ID,
					SpotifyID: artist.SpotifyID,
					Name:      artist.Name,
				})
				if err != nil {
					err = fmt.Errorf("failed to get/create artist: %w", err)
					return err
				}

				// insert album_artists
				_, err = tx.Queries().GetOrCreateAlbumArtist(ctx, sqlc.GetOrCreateAlbumArtistParams{
					AlbumID:  albumModel.ID,
					ArtistID: artistModel.ID,
				})
				if err != nil {
					err = fmt.Errorf("failed to get/create album artist: %w", err)
					return err
				}

				album.Artists[i] = NewArtistDTOFromModel(artistModel)
			}

			for i, release := range album.Releases {
				// insert releases
				releaseModel, err := tx.Queries().GetOrCreateRelease(ctx, sqlc.GetOrCreateReleaseParams{
					ID:      release.ID,
					AlbumID: album.ID,
					Format:  release.Format,
				})
				if err != nil {
					err = fmt.Errorf("failed to get/create release: %w", err)
					return err
				}

				// insert user_releases
				userRelease, err := tx.Queries().UpsertUserRelease(ctx, sqlc.UpsertUserReleaseParams{
					ID:        uuid.New().String(),
					UserID:    userId,
					ReleaseID: releaseModel.ID,
					AddedAt:   *release.AddedAt,
				})
				if err != nil {
					err = fmt.Errorf("failed to get/create user release: %w", err)
					return err
				}

				album.Releases[i] = NewReleaseDTOFromModel(releaseModel, &userRelease)
			}
		}

		return nil
	})

	return err
}
